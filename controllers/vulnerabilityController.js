// controllers/vulnerabilityController.js
import { v4 as uuidv4 } from "uuid";
import fs from "fs";
import Vulnerability from "../models/Vulnerability.js";
import ScanHistory from "../models/ScanHistory.js";
import Log from "../models/Log.js";
import { checkSuspiciousActivity } from "../utils/alertUtils.js";
import { sendMail } from "../config/mailer.js";

import { runVulnerabilityScan } from "../utils/scanner.js";
import { generateVulnerabilityReport } from "../utils/reportGenerator.js";

/* ---------------- LOG CREATION HELPER ---------------- */
// Any log with level "suspicious" / "error" / "warning"
// => checkSuspiciousActivity() => DB alert + socket.io + email
const createLog = async (
  level,
  message,
  keyword = [],
  metadata = {},
  userId = null,
  userEmail = null,
  ipAddress = "System",
  userAgent = "Vulnerability Scanner"
) => {
  try {
    console.log("üìù Creating log:", {
      level,
      message: message.substring(0, 60),
    });

    const log = await Log.create({
      level,
      message,
      keyword,
      ipAddress,
      userAgent,
      userId,
      userEmail,
      metadata,
    });

    // üî• Triggers real-time alerts via alertUtils + socket.io
    if (["suspicious", "error", "warning"].includes(level)) {
      await checkSuspiciousActivity(log, userEmail);
    }

    return log;
  } catch (error) {
    console.error("‚ùå Log creation error:", error);
  }
};

/* ------------- HELPER: RECALC SCAN COUNTS / CLEANUP ------------- */
const recalculateScanStats = async (scanIds = []) => {
  try {
    const uniqueIds = [...new Set(scanIds)].filter(Boolean);
    if (uniqueIds.length === 0) return;

    for (const scanId of uniqueIds) {
      const remaining = await Vulnerability.find({ scanId });

      if (!remaining || remaining.length === 0) {
        await ScanHistory.deleteOne({ scanId });
        console.log(
          `üßπ ScanHistory removed for scanId ${scanId} (no vulnerabilities left)`
        );
        continue;
      }

      const counts = {
        Critical: remaining.filter((v) => v.severity === "Critical").length,
        High: remaining.filter((v) => v.severity === "High").length,
        Medium: remaining.filter((v) => v.severity === "Medium").length,
        Low: remaining.filter((v) => v.severity === "Low").length,
      };

      await ScanHistory.findOneAndUpdate(
        { scanId },
        {
          totalVulnerabilities: remaining.length,
          criticalCount: counts.Critical,
          highCount: counts.High,
          mediumCount: counts.Medium,
          lowCount: counts.Low,
        }
      );

      console.log(`‚ôªÔ∏è ScanHistory updated for scanId ${scanId}`, counts);
    }
  } catch (err) {
    console.error("‚ùå recalculateScanStats error:", err);
  }
};

/* ---------------- CONTROLLERS ---------------- */

// START SCAN  (POST /scan)
export const startScan = async (req, res) => {
  const { siteUrl } = req.body;
  if (!siteUrl)
    return res.status(400).json({ message: "Site URL is required" });

  const scanId = uuidv4();
  const startTime = Date.now();

  try {
    await createLog(
      "info",
      `Vulnerability scan started for ${siteUrl}`,
      ["vulnerability", "scan", "started"],
      { scanId, siteUrl },
      req.user._id,
      req.user.email
    );

    await ScanHistory.create({
      scanId,
      siteUrl,
      userId: req.user._id,
      status: "In Progress",
      startedAt: new Date(),
    });

    console.log(`üîç Running scan ${scanId} for ${siteUrl}`);
    const vulnerabilities = await runVulnerabilityScan(siteUrl);

    const counts = {
      Critical: vulnerabilities.filter((v) => v.severity === "Critical").length,
      High: vulnerabilities.filter((v) => v.severity === "High").length,
      Medium: vulnerabilities.filter((v) => v.severity === "Medium").length,
      Low: vulnerabilities.filter((v) => v.severity === "Low").length,
    };

    await Vulnerability.insertMany(
      vulnerabilities.map((v) => ({ ...v, siteUrl, scanId }))
    );
    const duration = Math.round((Date.now() - startTime) / 1000);

    await ScanHistory.findOneAndUpdate(
      { scanId },
      {
        status: "Completed",
        totalVulnerabilities: vulnerabilities.length,
        criticalCount: counts.Critical,
        highCount: counts.High,
        mediumCount: counts.Medium,
        lowCount: counts.Low,
        duration,
        completedAt: new Date(),
      }
    );

    const hasCriticalOrHigh = counts.Critical > 0 || counts.High > 0;
    const hasMedium = counts.Medium > 0;

    let overallLevel = "info";
    if (hasCriticalOrHigh) {
      overallLevel = "suspicious";
    } else if (hasMedium) {
      overallLevel = "warning";
    }

    // This single log is enough to trigger real-time alert
    await createLog(
      overallLevel,
      `Scan completed for ${siteUrl} - Critical: ${counts.Critical}, High: ${counts.High}, Medium: ${counts.Medium}, Low: ${counts.Low} (Total: ${vulnerabilities.length})`,
      ["scan", "vulnerability", "summary", overallLevel],
      {
        scanId,
        siteUrl,
        severitySummary: counts,
        totalVulnerabilities: vulnerabilities.length,
        duration,
      },
      req.user._id,
      req.user.email
    );

    res.status(200).json({
      success: true,
      message: "Scan completed successfully",
      scanId,
      siteUrl,
      total: vulnerabilities.length,
      severity: counts,
      duration,
    });
  } catch (error) {
    console.error("‚ùå Scan Error:", error);

    await ScanHistory.findOneAndUpdate(
      { scanId },
      { status: "Failed", errorMessage: error.message, completedAt: new Date() }
    );

    await createLog(
      "error",
      `Scan failed for ${siteUrl} - ${error.message}`,
      ["vulnerability", "scan", "failed"],
      { scanId, siteUrl, error: error.message },
      req.user._id,
      req.user.email
    );

    res.status(500).json({
      success: false,
      message: "Failed to perform scan",
      error: error.message,
    });
  }
};

// GET ALL VULNS  (GET /)
export const getVulnerabilities = async (req, res) => {
  try {
    const { severity, status, siteUrl, scanId, page = 1, limit = 50 } =
      req.query;
    const filter = {};
    if (severity) filter.severity = severity;
    if (status) filter.status = status;
    if (siteUrl) filter.siteUrl = new RegExp(siteUrl, "i");
    if (scanId) filter.scanId = scanId;

    const skip = (parseInt(page) - 1) * parseInt(limit);
    const vulnerabilities = await Vulnerability.find(filter)
      .sort({ detectedAt: -1 })
      .skip(skip)
      .limit(parseInt(limit));

    const total = await Vulnerability.countDocuments(filter);

    res.json({
      vulnerabilities,
      pagination: {
        total,
        page: parseInt(page),
        pages: Math.ceil(total / parseInt(limit)),
        limit: parseInt(limit),
      },
    });
  } catch (err) {
    console.error("‚ùå Fetch Error:", err);
    res.status(500).json({
      message: "Error fetching vulnerabilities",
      error: err.message,
    });
  }
};

// EXPORT PDF  (GET /export)
export const exportVulnerabilitiesPdf = async (req, res) => {
  try {
    const { scanId, siteUrl } = req.query;
    console.log("üßæ Export request received:", {
      scanId,
      siteUrl,
      user: req.user?._id,
    });

    const filter = {};
    if (scanId) filter.scanId = scanId;
    if (siteUrl) filter.siteUrl = siteUrl;

    let vulnerabilities = await Vulnerability.find(filter).sort({
      severity: 1,
      detectedAt: -1,
    });
    console.log(
      `üß© Found ${vulnerabilities.length} vulnerabilities for export (initial filter)`
    );

    if ((!vulnerabilities || vulnerabilities.length === 0) && scanId && !siteUrl) {
      const scanInfoFallback = await ScanHistory.findOne({ scanId });
      if (scanInfoFallback?.siteUrl) {
        console.log(
          "üîÅ No vulns for scanId, falling back to siteUrl:",
          scanInfoFallback.siteUrl
        );
        vulnerabilities = await Vulnerability.find({
          siteUrl: scanInfoFallback.siteUrl,
        }).sort({ severity: 1, detectedAt: -1 });
        console.log(
          `üß© Fallback found ${vulnerabilities.length} vulnerabilities for export`
        );
      }
    }

    if (!vulnerabilities || vulnerabilities.length === 0) {
      return res.status(404).json({
        message: `No vulnerabilities found to export for scanId: ${
          scanId || "N/A"
        }`,
      });
    }

    let scanInfo = null;
    try {
      scanInfo = await ScanHistory.findOne({ scanId });
    } catch {
      console.log("‚ö†Ô∏è No ScanHistory found, proceeding anyway");
    }

    const reportData = {
      siteUrl: siteUrl || scanInfo?.siteUrl || vulnerabilities[0].siteUrl,
      startedAt: scanInfo?.startedAt || vulnerabilities[0].detectedAt,
      duration: scanInfo?.duration || "N/A",
      status: scanInfo?.status || "Completed",
      totalVulnerabilities: vulnerabilities.length,
      criticalCount: vulnerabilities.filter((v) => v.severity === "Critical")
        .length,
      highCount: vulnerabilities.filter((v) => v.severity === "High").length,
      mediumCount: vulnerabilities.filter((v) => v.severity === "Medium")
        .length,
      lowCount: vulnerabilities.filter((v) => v.severity === "Low").length,
      vulnerabilities,
    };

    const reportsDir = "./reports";
    if (!fs.existsSync(reportsDir)) fs.mkdirSync(reportsDir, { recursive: true });
    const fileName = `vulnerability_report_${Date.now()}.pdf`;
    const filePath = `${reportsDir}/${fileName}`;
    console.log("üìÑ Generating PDF:", filePath);

    await generateVulnerabilityReport(reportData, filePath);
    await createLog(
      "info",
      `Report generated for ${reportData.siteUrl}`,
      ["vulnerability", "export"],
      { scanId, siteUrl, fileName },
      req.user._id,
      req.user.email
    );

    sendReportEmail(req.user.email, reportData, filePath).catch((err) =>
      console.error("Email send error (non-blocking):", err.message)
    );

    res.download(filePath, fileName, (err) => {
      if (err) console.error("‚ùå Download error:", err);
      setTimeout(() => {
        try {
          if (fs.existsSync(filePath)) fs.unlinkSync(filePath);
        } catch (cleanupErr) {
          console.error("File cleanup error:", cleanupErr);
        }
      }, 5000);
    });
  } catch (err) {
    console.error("‚ùå Export Error:", err);
    res.status(500).json({
      message: "Error generating PDF report",
      error: err.message,
    });
  }
};

// STATS + RECENT SCANS (GET /stats)
export const getVulnerabilityStats = async (req, res) => {
  try {
    const [total, critical, high, medium, low, open, resolved] =
      await Promise.all([
        Vulnerability.countDocuments(),
        Vulnerability.countDocuments({ severity: "Critical" }),
        Vulnerability.countDocuments({ severity: "High" }),
        Vulnerability.countDocuments({ severity: "Medium" }),
        Vulnerability.countDocuments({ severity: "Low" }),
        Vulnerability.countDocuments({ status: "Open" }),
        Vulnerability.countDocuments({ status: "Resolved" }),
      ]);

    let recentScans = await ScanHistory.find({ userId: req.user._id })
      .sort({ startedAt: -1 })
      .limit(50);

    const filtered = [];
    for (const scan of recentScans) {
      const exists = await Vulnerability.exists({ scanId: scan.scanId });
      if (exists) filtered.push(scan);
    }

    res.json({
      total,
      severity: { critical, high, medium, low },
      status: { open, resolved },
      recentScans: filtered,
    });
  } catch (err) {
    console.error("‚ùå Stats Error:", err);
    res.status(500).json({
      message: "Error fetching statistics",
      error: err.message,
    });
  }
};

// SCAN HISTORY LIST (GET /scans)
export const getScanHistory = async (req, res) => {
  try {
    let scans = await ScanHistory.find({ userId: req.user._id })
      .sort({ startedAt: -1 })
      .limit(50);

    const filtered = [];
    for (const scan of scans) {
      const exists = await Vulnerability.exists({ scanId: scan.scanId });
      if (exists) filtered.push(scan);
    }

    res.json(filtered);
  } catch (err) {
    console.error("‚ùå Scan History Error:", err);
    res.status(500).json({ message: "Error fetching scan history" });
  }
};

// UPDATE STATUS (PATCH /:id/status)
export const updateVulnerabilityStatus = async (req, res) => {
  try {
    const { status } = req.body;
    if (!["Open", "In Progress", "Resolved", "Ignored"].includes(status)) {
      return res.status(400).json({ message: "Invalid status" });
    }
    const update = { status };
    if (status === "Resolved") {
      update.resolvedAt = new Date();
      update.resolvedBy = req.user._id;
    }
    const vulnerability = await Vulnerability.findByIdAndUpdate(
      req.params.id,
      update,
      { new: true }
    );
    if (!vulnerability)
      return res.status(404).json({ message: "Vulnerability not found" });

    await createLog(
      "info",
      `Status updated to ${status}`,
      ["vulnerability", "status"],
      { id: vulnerability._id },
      req.user._id,
      req.user.email
    );

    res.json(vulnerability);
  } catch (err) {
    console.error("‚ùå Update Status Error:", err);
    res.status(500).json({
      message: "Error updating vulnerability status",
      error: err.message,
    });
  }
};

// BULK DELETE (DELETE /bulk)
export const bulkDeleteVulnerabilities = async (req, res) => {
  try {
    const { ids } = req.body;
    if (!ids || !Array.isArray(ids) || ids.length === 0)
      return res.status(400).json({
        success: false,
        message: "No vulnerability IDs provided",
      });

    const mongoose = await import("mongoose");
    const validIds = ids.filter((id) => mongoose.Types.ObjectId.isValid(id));
    if (validIds.length === 0)
      return res.status(400).json({
        success: false,
        message: "No valid vulnerability IDs provided",
      });

    const toDelete = await Vulnerability.find({
      _id: { $in: validIds },
    }).select("scanId");
    const affectedScanIds = toDelete.map((v) => v.scanId);

    const result = await Vulnerability.deleteMany({ _id: { $in: validIds } });

    await createLog(
      "info",
      `Bulk delete: ${result.deletedCount} vulnerabilities`,
      ["vulnerability", "bulk-delete"],
      { ids },
      req.user._id,
      req.user.email
    );

    await recalculateScanStats(affectedScanIds);

    res.json({
      success: true,
      message: `${result.deletedCount} vulnerabilities deleted successfully`,
    });
  } catch (err) {
    console.error("‚ùå Bulk Delete Error:", err);
    res.status(500).json({
      success: false,
      message: "Error deleting vulnerabilities",
      error: err.message,
    });
  }
};

// DELETE SINGLE (DELETE /:id)
export const deleteVulnerability = async (req, res) => {
  try {
    const vulnerability = await Vulnerability.findById(req.params.id);
    if (!vulnerability)
      return res.status(404).json({ message: "Vulnerability not found" });

    const scanId = vulnerability.scanId;

    await vulnerability.deleteOne();

    await createLog(
      "info",
      `Deleted vulnerability ${vulnerability.type}`,
      ["vulnerability", "delete"],
      { id: vulnerability._id },
      req.user._id,
      req.user.email
    );

    await recalculateScanStats([scanId]);

    res.json({ success: true, message: "Vulnerability deleted successfully" });
  } catch (err) {
    console.error("‚ùå Delete Error:", err);
    res.status(500).json({
      success: false,
      message: "Error deleting vulnerability",
      error: err.message,
    });
  }
};

/* ---------------- EMAIL HELPER ---------------- */
const sendReportEmail = async (userEmail, reportData, filePath) => {
  try {
   await sendMail({
  to: userEmail,
  subject: "Vulnerability Scan Report (PDF)",
  html: `
    <div style="font-family: Arial;">
      <h2>Vulnerability Scan Report</h2>
      <p>Site: ${reportData.siteUrl}</p>
      <p>Total Issues: ${reportData.totalVulnerabilities}</p>
      <p>Critical: ${reportData.criticalCount}</p>
      <p>High: ${reportData.highCount}</p>
    </div>
  `
});

    console.log("‚úÖ Report email sent to:", userEmail);
  } catch (err) {
    console.error("‚ùå Report email error:", err.message);
  }
};
